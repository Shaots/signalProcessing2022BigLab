# signalProcessing2022BigLab
## Постановка задачи
### Цель
Требуется создать “Intelligent Placer”: по поданной на вход фотографии нескольких предметов (не больше 10 предметов) на светлой горизонтальной поверхности и многоугольнику понимать, можно ли расположить одновременно все эти предметы на плоскости так, чтобы они влезли в этот многоугольник. <br>
“Intelligent Placer” должен быть оформлен в виде python-библиотеки **intelligent_placer_lib**, которая поставляется каталогом **intelligent_placer_lib** с файлом **intelligent_placer.py**, содержащим функцию
```python
def check_image(strPathToImg)
```
### Вход и выход 
Входа к этой функции: **АБСОЛЮТНЫЙ** путь к фотографии предметов, имеющий тип string <br>
Выход: True если предметы могут влезть в многоугольник, иначе False. То есть так, чтобы работал код:
```python
from intelligent_placer_lib import intelligent_placer
def test_intelligent_placer():
	assert intelligent_placer.check_image(“C:/Users/shaot/code/image.png”)
```

### Требование
#### Требования к фотографии
1. фото должно иметь расширение .png или .jpg.
2. фон фото является белым листом.
3. высота съемки должна быть больше 10 см, и меньше 20 см.
4. камера должна быть направлена верникально вниз, разрешаю отклонение в 2 стороны на 5 градусов.
#### Требования к многоугольнику
1. многоугольник может быть как выпуклым, так и вогнутым.
2. число вершин многоугольника не больше 10.
3. количество ребер многоугольника должно быть явно различимо

#### Требования к предмету
1. границы всех предметов должны четко выделяться на фоне белого листа бумаги.
2. меньшая из сторон предмета была не менее 20 пикселей, а большая - не больше 200
3. предметы не должны перекрывать друг друга
5. нельзя повернуть предмет на каколй-либо угол, но можно поступательно двигать его.
8. высота предмета не должны быть больше 3 см.
9. один предмет может присутствовать на фото лишь 1 раз.
10. предметы могут иметь разные ориентации/направление.
### Сбор данных
[dataset](https://disk.yandex.ru/d/SmLf_oLTA4gXsw)


### План решения

1. Найти края на изображении
	1. Понизить размерность изображение для ускорения
	2. Сделать шумоподавление
	3. Примеить метод Canny чтобы искать границу
2. Отфильтровать лишние края, оставив только многоугольник и объект
 	1. Разширять границы, чтобы они стали толще
	2. Применить метод наводнение чтобы выделить внутренность многоугольника
	3. Объединить объекты, границу многоугольника с внутренностью многоугольника
	4. Разрушать границы и этот проецесс одновременно позволяет мелчивать шум
	5. Покрасить фон черным цветом 0, объект серым цветом 128 и многоугольник белым цветом 255.
3. Попробовать совместить многоугольник и объект и, если удается поместить объект внутрь, сказать, что помещается.
	1. Найти минимальный прямоугольник, охыватывающий объект. Обозначим **recObj**
	2. Найти минимальный прямоугольник, охватывающий многоугольник. Обозначим **recPolygon**
	3. Записывать площадь recPolygon через **sourceArea**
	4. Первая проверка: если хотя бы одно из длины, ширины recObj больше чем recPolygon, то сразу сказать объект не подходит ***Flase***
	5. Поставим левый верхний угол объекта в точку (i, j) многоугольник
	6. Копировать матрицу, полученную из второго этапа "Отфильтровать". Обозначим **temp**
	7. Покрасить часть temp \[i -- i + dlina recObj, j -- j + shilina recObj\], не являющуюся фоном, серым цветом
	8. Получится объединение объекта и многоугольника.
	9. Если площадь части объединения, не являющейся фоном, равна sourceArea, то можем сказать, что объект помещается внутрь многоугольника. ***True***. В противном случае, объект не помещается внутрь многоугольника. False. Потому что может в пункте 7 покрасили фон серым цветом.
	10. Возвращаться в пункт 5 сделать следующую итерацию

Замечание: данный алгоритм подходит как в случае выпуклого многоугольника так и в случае вогнутого многоугольника.
